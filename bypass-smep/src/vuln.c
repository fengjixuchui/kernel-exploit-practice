#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/miscdevice.h>
#include <linux/fs.h>
#include <linux/uaccess.h>
#include <linux/errno.h>
#include "vuln.h"

struct miscdevice vuln_dev;
struct file_operations vuln_fops =
{
.unlocked_ioctl=vuln_ioctl,
.open=vuln_open,
.release=vuln_release,
};

struct rwRequest {
	void *kaddr;
	void *uaddr;
	size_t length;
};

static int __init vuln_init(void) {
	vuln_dev.minor = MISC_DYNAMIC_MINOR;
	vuln_dev.name = "vuln";
	vuln_dev.fops = &vuln_fops;

	if (misc_register(&vuln_dev) < 0) {
		printk(KERN_ERR  "Failed to install vulnerable module\n");
	}
	printk(KERN_INFO "Installed vulnerable module\n");
	return 0;
}
static void __exit vuln_exit(void) {

	misc_deregister(&vuln_dev);
	printk(KERN_INFO "Released vulnerable module!\n");
}

long vuln_ioctl (struct file *filp, unsigned int cmd, unsigned long arg) {

	struct rwRequest req;

	if (cmd == 0x1111) {
		// arbitrary read
		if (copy_from_user(&req, (void *)arg, sizeof(req))) {
			printk(KERN_ERR "invalid address in arbitrary read");
			return -EFAULT;
		}

		if (copy_to_user(req.uaddr, req.kaddr, req.length)) {
			printk(KERN_ERR "invalid address in arbitrary read");
			return -EFAULT;
		}
	}

	if (cmd == 0x2222) {
		// arbitrary write
		if (copy_from_user(&req, (void *)arg, sizeof(req))) {
			printk(KERN_ERR "invalid address in arbitrary write");
			return -EFAULT;
		}

		if (copy_from_user(req.kaddr, req.uaddr, req.length)) {
			printk(KERN_ERR "invalid address in arbitrary write");
			return -EFAULT;
		}
	}

	if (cmd == 0x3333) {
		// return a stack address
		void *stack_addr = &req;
		if (copy_from_user(&req, (void *)arg, sizeof(req))) {
			printk(KERN_ERR "invalid address in stack leak");
			return -EFAULT;
		}

		if (copy_to_user(req.uaddr, &stack_addr, sizeof(stack_addr))) {
			printk(KERN_ERR "invalid address in stack leak");
			return -EFAULT;
		}
	}

	if (cmd == 0x4444) {
		// return the top level page directory
		void *pgd = get_current()->mm->pgd;
		if (copy_from_user(&req, (void *)arg, sizeof(req))) {
			printk(KERN_ERR "invalid address in pgd leak");
			return -EFAULT;
		}

		if (copy_to_user(req.uaddr, &pgd, sizeof(pgd))) {
			printk(KERN_ERR "invalid address in pgd leak");
			return -EFAULT;
		}
	}
	return 0;
}
int vuln_open(struct inode *inod, struct file *fil) {
	return 0;
}

int vuln_release(struct inode *inod,struct file *fil){
	return 0;
}

module_init(vuln_init);
module_exit(vuln_exit);
